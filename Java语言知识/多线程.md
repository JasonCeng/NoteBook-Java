# 多线程

## 目录

## 1.介绍
* **进程：**进程指正在运行的程序。确切的说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。

* **线程：**线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个线程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

  简而言之，一个程序运行后至少有一个进程，一个进程中可以包含多个线程。
那么，什么是单线程，又什么是多线程呢？

* **单线程程序：**即若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。

* **多线程程序：**即若有多个任务可以同时执行。

## 2.程序运行原理

* **分时调度：**所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。

* **抢占式调度：**抢先让优先级搞的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。

  * 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。实际上，CPU（中央处理器）使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而CPU在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实多线程并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。

## 3.主线程
当我们在命令行中输入：**java 空格 类名 回车**后，启动JVM，并且加载对应的class文件。虚拟机会从main方法开始执行我们的程序代码，一直把main方法的代码执行结束。

如果在执行过程遇到循环时间比较长的代码，那么在循环之后的其他代码是不会马上执行的。原因是：**JVM启动后，必然有一个执行路径（线程）是从main方法开始的,一直执行到main方法结束，这个线程在java中称之为主线程。**当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后才能继续执行。

## 4.Thread类
我们可以通过Thread类创建线程。Thread是程序中的执行线程，Java虚拟机允许应用程序并发地运行多个执行线程。

* **构造方法**
  * **Thread()** 分配新的Thread对象。
  * **Thread(String name)** 分配新的Thread对象，将指定的name作为其线程名称。

* **常用方法**
  * **void start()** 使该线程开始执行；Java虚拟机调用该线程的run方法。
  * **void run()** 该线程要执行的操作。
  * **static void sleep(long millis)** 让当前正在执行的线程休眠（暂停执行）指定的毫秒数。

* **创建新进程的方法**
  * **法一：将类声明为Thread的子类。**该子类应重写Thread类的run方法。创建对象，开启线程。run方法相当于其他线程的main方法。
  * **法二：声明一个实现Runnable接口的类。**在该类中实现run方法，然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。

## 5.创建线程方式一：继承Thread类

* **创建线程的步骤：**

  1.定义一个类继承Thread

  2.重写run方法

  3.创建子类对象，即创建线程对象

  4.调用start方法，开启线程并让线程执行，同时会通知JVM去调用run方法。

  ```java
  public class ThreadDemo01 {
    public static void main(String[] args){
      MyThread mt = new MyThread("新的线程！");
      //开启新线程
      mt.start();
      //在主方法中执行for循环
      for(int i = 0; i < 10; i++) {
        System.out.println("main线程！" + i);
      }
    }
  }

  /**
  *自定义线程类
  */
  public class MyThread extends Thread {
    //定义指定线程名称的构造方法
    public MyThread(String name){
      //调用父类的String参数的构造方法，指定线程的名称
      super(name);
    }
    /**
    *重写run方法，完成该线程执行的逻辑
    */
    @Override
    public void run(){
      for(int i = 0; i < 10; i++){
        System.out.println(getName() + ":正在执行！" + i);
      }
    }
  }
  ```
* **思考：线程对象调用run方法和调用start方法区别？**

  答：线程对象调用run方法不开启线程，仅是对象调用方法。线程对象调用start开启线程，并让JVM调用run方法在线程中执行。

* **继承Thread类原理**
